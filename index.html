<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotation Leiden</title>
</head>
<body>
    <h1>Rotation Leiden</h1>
    <p>Visualization of Kenneth Martin's Rotation Frankfurt pattern</p>

    <script>
        const lineDefinitions = [
    [3,7],
    [7,11],
    [11,15],
    [15,12],
    [12,8],
    [8,4],
    [4,0],
    [0,2],
    [2,6],
    [6,10],
    [10,14],
    [14,13],
    [13,9],
    [9,5],
    [5,1]
];

// R = red
// O = orange
// W = white
// G = green
// B = blue
const colors = ['R','O','W','G','B','R','O','W','G','B','R','O','W','G','B'];


        function getRedDotCoordinates(canvasSize) {
            const results = [];

            const Xc = canvasSize / 2; // X-coordinate of the center of the canvas/large circle
            const Yc = canvasSize / 2; // Y-coordinate of the center of the canvas/large circle

            // Radius of the large outer circle
            const R_L = canvasSize / 2;

            // Radius of each of the four small inner circles
            // R_L = r_sc * (1 + sqrt(2))  => r_sc = R_L / (1 + sqrt(2))
            // Multiplying by (sqrt(2)-1)/(sqrt(2)-1) gives r_sc = R_L * (sqrt(2)-1)
            const r_sc = R_L * (Math.sqrt(2) - 1);

            // Define the centers of the four small inner circles.
            // The offset from (Xc, Yc) to these centers is r_sc itself.
            const circleCenters = [
                { x: Xc - r_sc, y: Yc - r_sc }, // Top-left circle center
                { x: Xc + r_sc, y: Yc - r_sc }, // Top-right circle center
                { x: Xc - r_sc, y: Yc + r_sc }, // Bottom-left circle center
                { x: Xc + r_sc, y: Yc + r_sc }  // Bottom-right circle center
            ];

            for (const center of circleCenters) {
                const c_ix = center.x;
                const c_iy = center.y;

                // Calculate the 4 red dots (vertices of the inscribed square) for the current inner circle.
                // Order: Top, Left, Right, Bottom.
                const points = [
                    [c_ix,           c_iy - r_sc], // Top vertex
                    [c_ix - r_sc,    c_iy],         // Left vertex
                    [c_ix + r_sc,    c_iy],         // Right vertex
                    [c_ix,           c_iy + r_sc]  // Bottom vertex
                ];

                // Add points to the results array
                for (const point of points) {
                    results.push(point);
                }
            }

            return results;
        }

        function applyMappings(coordinates) {
            // Define the mapping patterns
            const mapping0 = [1,0,8,9,2,15,7,10,14,3,11,6,13,12,4,5];
            const mapping1 = [12,13,1,0,3,14,2,15,11,6,10,7,4,5,9,8];
            const mapping2 = [11,6,14,3,4,5,13,12,8,9,1,0,7,10,2,15];
            const mapping3 = [10,7,11,6,9,8,4,5,1,0,12,13,2,15,3,14];

            // Apply each mapping to create four new arrays
            const mappedArrays = [
                mapping0.map(index => coordinates[index]),
                mapping1.map(index => coordinates[index]),
                mapping2.map(index => coordinates[index]),
                mapping3.map(index => coordinates[index])
            ];

            return mappedArrays;
        }

        // Example usage:
        const canvasWidth = 100;
        const coordinates = getRedDotCoordinates(canvasWidth);
        console.log('Original coordinates:', coordinates);
        
        const mappedCoordinates = applyMappings(coordinates);
        console.log('Mapped coordinates:', mappedCoordinates);
        // This will output an array of four arrays, each containing 16 coordinates in the mapped order
    </script>
</body>
</html>